# Saturn V

Saturn V is an implementation of a general-purpose decision engine.

It is named after the [Saturn V](https://en.wikipedia.org/wiki/Saturn_V) rocket engine because it is my fifth iteration on a general-purpose decision engine design. The name can also be interpreted as an homage to Japan's [Fifth Generation Computer Systems](https://en.wikipedia.org/wiki/Fifth_Generation_Computer_Systems) project.

At the moment, Saturn V is incomplete, but its early code and documentation is available on this repository.

## What's a decision engine?

Making decisions is hard. What to eat for breakfast? What clothes do I wear? Do I need to bring a coat? What homework do I need to do? Do I need to go shopping? These decisions add up, and there is a limit to how many good decisions a person can make in a given timespan. When this limit is reached, it is called [decision fatigue](https://www.ama-assn.org/delivering-care/public-health/what-doctors-wish-patients-knew-about-decision-fatigue).

A massive amount of effort every day is expended on making these very small decisions. To many, this becomes a point of self-expression: developing a fashion sense, cooking unique and fresh food at home, or developing personalized diets to suit their body goals. However, in the information age, the number of decisions we make on a daily basis is [massively rising](https://finance.yahoo.com/news/exhaustion-modern-life-decision-fatigue-180410366.html). Soon, everyone will need to have to carefully tailor their internet hygiene, routines, work schedules, and housework around this upper limit in human executive function.

Many people are already severely affected by decision fatigue. To the depressed, autistic, ADHD, chronically fatigued, [spoonie](https://en.wikipedia.org/wiki/Spoon_theory), or other mentally ill or disabled person, even doing the bare minimum to participate in modern society is fatiguing. Many people do not even have the ability to replenish their decision-making energy after what most people consider to be a suitable rest period, leading to long-term or chronic decision fatigue. For neurodivergent folks, there are very few cultural support structures in place to help neurodivergent people to make their lives work for their brains. Decision fatigue is a major aspect to the fact that the current status quo is simply not suited to the mentally ill or disabled.

I personally am depressed, ADHD, and *very* autistic, leading me to have an idea. How many of these minor, day-to-day decisions can be simply automated away? After all, we live in an era with access to massive amounts of computing power per capita. Just how many decisions in modern life can be simply delegated to an algorithm? I call the hypothetical algorithm that can take on this responsibility a "decision engine." The idea is simple: most of the small choices we make are based on very simple rules with complex interactions between them. A sufficiently advanced computer program should be capable of making those choices if it was made aware of those rules and interactions.

If everyday tasks could truly be automated in the full context of the rest of someone's life, imagine what that could do for society. One way of thinking about it is as a "prosthetic habits" system, like a cybernetic implant that allows people to spend their scarce decisions on more important, productive, or valuable things than the minutiae. Disabled and neurodivergent people might find life much easier to approach and succeed at a higher number of personal and important goals. If self-reflection and mindfulness activities were integrated into the engine as well, it could generally elevate one's ability to respond to and support themselves in the environment around them. Adding new rules and options to the decision engine does not tax the engine like it taxes an individual, meaning that individual habits become much easier to commit to, and it may push the upper limit on how many self-enrichment activities can be committed to for even averagely-abled people.

A decision engine would, of course, have to be both extremely personalized and complex. There are many, many factors contributing to all of the minor events and tasks going on in one's life. Designing an algorithm to coordinate someone's entire life is an essence a data integration problem. Luckily, as of the Web 2.0 boom, data integration is arguably what computers are best at in the moment. The little decisions driving a single person's entire life are a drop in the bucket compared to what modern data centers process every single day.

This approach to solving decision fatigue would clearly have a lot of wide appeal. So, why doesn't it already exist? I believe that the reason is because the state of the data processing technology that could implement a decision engine is both fragmented and alienated from the user.

Since the smartphone boom of the late 2000s, everybody wants to make "the killer app." Every app clamors for your attention and a download onto your device, and the result is that each individual app has diminishing returns on how much data processing and functionality it can offer alone. This app overpopulation becomes yet another axis of decision fatigue because now *you*, the user, are responsible for coordinating all of these loud, bratty, antisocial apps into a meaningful whole. There are meal planner apps, grocery list apps, calendar apps, and video call apps, but there isn't an app that can remind you to buy bananas today because otherwise you won't have time for breakfast before your 6:00 AM Zoom meeting.

Despite the fact that the technology to augment entire lives exists, it is not being applied towards that end. In fact, it leads to the opposite: data analytics are the crux of social media, targeted advertising, and browser tracking technologies. These are the very things that are causing this pandemic of decision fatigue in the first place. To the average consumer it's a chronic inconvenience and to the disabled it's life-destroying. Google and Microsoft attempt to build the "super-app" to some extent through their own suites of integrated productivity tools. However, how personal, private, or modular could such a thing be? These massive companies profit off of your poor executive function in the first place, so why should they care about your 5:30 AM banana?

The solution to this is not something that the app market or Silicon Valley hype could accomplish on its own. *You have to give the technology back to the people.* By making the decision engine [free software](https://en.wikipedia.org/wiki/Free_software), [self-hostable](https://en.wikipedia.org/wiki/Self-hosting_(web_services)), and as modular as possible, the decision engine moves from a hypothetical super-app to a practical system you can design. If it is licensed under a strong [copyleft](https://en.wikipedia.org/wiki/Copyleft) license, this guarantees that the community of decision engine users can maintain compatibility with each other, building an open network of people sharing their decision-making profiles with each other. It also rescues the decision engine from falling back into the same sort of app developer fragmentation.

So let's recap. The decision engine needs to be:
1. **Personal**: The engine is supposed to be a cybernetic implant, right? Every user needs to have an extremely high degree of customizability over their own instance of the decision engine. All of your own weird lifestyle quirks should be a joy to factor into the system, not a nuisance.
2. **Modular**: The decision engine is supposed to be for everyone, so it needs to support an unbounded amount of extensibility. Any specific top-level design decisions would be presumptive at best or alienating at worst. I'm sick of apps following "good app design" in a little feature sandbox and limiting what I can do with them.
3. **Networked**: Making healthy, context-aware decisions requires a vast wealth of information about your own situation. It is critical that the decision engine is capable of integrating with arbitrary sources of external data such as calendars, map information, weather forecasts, or food prices.
4. **Open**: You're going to be putting all sorts of personal data into this thing, maybe even secrets you wouldn't tell anyone else. It should run on hardware you have access to and you should have a guarantee that it is not instrumented into some corporate data analytics system.
5. **Free**: If the decision engine becomes a "product" for sale or some Google-maintained [SaaS](https://en.wikipedia.org/wiki/Software_as_a_service), all of the prior points are at risk of compromise. Strong free software licensing and a tightknit userbase demonstrating solidarity towards this end are critical.

# Architecture

```
parse -> type-infer -> desugar -> lower -> check -> evaluate -> solve
```

- **parse**: Saturn V incrementally parses updates to Kerolox source files using [tree-sitter](https://tree-sitter.github.io/), then loads the resulting syntax trees into incremental [Salsa](https://salsa-rs.github.io/salsa/) data structures. This is the source of all the inputs to the incremental frontend.
- **type-infer**: Kerolox programs are type-inferred at a high level using explicit relation definitions and type constraint rules applied on the expression levels. This gives every variable and expression in a program a concrete type and reports error diagnostics when types are inconsistent or unknown.
- **desugar**: The typing information is used by Saturn V to desugar the Kerolox types and values into Saturn V's intermediate representation (IR). For example, tuple types are flattened into lists of primitive values. All Saturn V relations ultimately end up as flat relations with columns of only primitive types.
- **lower**: Although desugaring has transformed the logical representation of Kerolox of semantics into IR, the IR is still purely logical and does not instruct Saturn V how to operate on relations to meet those semantics. The program's IR is fed into [egglog](https://github.com/egraphs-good/egglog), a state-of-the-art [equality graph (e-graph)](https://en.wikipedia.org/wiki/E-graph) implementation, to extract an equivalent relational program that can be actually be executed. The relational program is represented as a forest of [bottom-up](https://en.wikipedia.org/wiki/Datalog) relational operations.
- **check**: Some undesirable or unexpected properties of programs such as infinite recursion or unused relations can be detected using [Z3](https://github.com/Z3Prover/z3)'s [fixed-point engine](https://microsoft.github.io/z3guide/docs/fixedpoints/intro). This can provide warning diagnostics to users as they write programs, but in the future, it may also be used to ensure the safety of untrusted Saturn V programs before running them. Z3's fixed-point features are designed to check program safety in procedural environments, but luckily, we're already in a Horn clause-based system! It's a match made in heaven.
- **evaluate**: Now that the IR describes concrete relational operations instead of pure logical relations, it is passed to a [Differential Dataflow](https://github.com/TimelyDataflow/differential-dataflow) engine that incrementally populates the contents of each relation. It also assembles a model of the logical relationships between each entry in the program's decision relations. These relationships are eventually gathered in the top-level constraint operations, which emit constraints on decision values in propositional logic.
- **solve**: The constraints, set of active decisions, and logical relations are passed to a decoupled solving engine, which uses a [SAT solver](https://en.wikipedia.org/wiki/SAT_solver) to select decisions which meet all of the constraints. Because the evaluation engine's output is incremental, the solving engine's SAT instance can be kept across updates and extended with minor changes to inputs, responding with low latency instead of solving the program from scratch.

The steps of the pipeline between "parse" and "check" can be considered the "frontend" of Saturn V, because they reason about Kerolox programs without evaluating them or making any decisions. The Saturn V "backend" is composed of the evaluation and solve steps, which run separately and can be asynchronously loaded with new, valid IR code. In other words, the Saturn V frontend is everything that runs in a language server or IDE, and the backend runs long-term on a dedicated server machine and is dynamically loaded with new code over time.
