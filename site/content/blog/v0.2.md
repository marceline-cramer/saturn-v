+++
title = "Saturn V version 0.2"
description = "What to know about the most recent v0.2 release."
date = 2025-01-03
authors = ["Marceline Cramer"]

[extra]
giscus = true
+++

# Saturn V version 0.2

Yeah, it's only been like two weeks since I released version v0.1. I also didn't really say anything about it. Well, that's because it isn't really a big deal! That's kind of the point. [Release early, release often](https://en.wikipedia.org/wiki/Release_early,_release_often).

No, I *don't* have testers or users yet, but whatever. I'm still ironing out the release pipeline, since (fun fact) this is the first time I've ran a hobby project that had "real" binary releases and wasn't just eternally trapped in pre-alpha. Well, that changes *now*... even if it means that I have to spend consecutive late nights figuring out how the hell to get Saturn V release builds to compile on OpenBSD in GitHub Actions.

# Rudimentary Python bindings

# Pure WebAssembly VSCode extension

# Negation as failure

# Three-body problem loading icon

# MaxSAT solver goes vroom vroom

You may have heard me babble about SAT (aka [the Boolean satisfiability problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)). SAT solvers are how Saturn V makes its decisions. Well, [MaxSAT](https://en.wikipedia.org/wiki/Maximum_satisfiability_problem) (particularly *partial weighted MaxSAT*) is how Saturn V determines that some decisions are better than others.

For example, let's take this Saturn V program:

```rp1
; Each possible coordinate on the board.
define output Coord Integer.
Coord 1.
Coord a :- Coord b, b < 8, a = b + 1.

; Each possible placement of a queen.
define output decision Queen(Coord, Coord).
Queen(row, col) :- Coord row, Coord col.

; At most one queen goes on each row.
constrain(row) <= 1 :- Queen(row, col).

; At most one queen goes on each column.
constrain(col) <= 1 :- Queen(row, col).

; At most one queen can go along each main diagonal.
constrain(diag) <= 1 :- Queen(row, col), diag = row + col.

; At most one queen can go along each orthogonal diagonal.
constrain(diag) <= 1 :- Queen(row, col), diag = row - col.

; Try to place as many queens as possible.
constrain soft(1) (coord) = 1 :- Queen coord.
```

This is identical to the [n-queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) example except that instead of specifying that *exactly* one queen goes on each row and column, *at most* one queen goes on each row and column. This allows for there to be no queens placed on the board, so we also add that last soft constraint:

```rp1
; Try to place as many queens as possible.
constrain soft(1) (coord) = 1 :- Queen coord.
```

Whereas n-queens is a basic constraint solving problem, this expression of it
is an optimization problem instead. We're trying to place, using a soft constraint, one queen on each coordinate. The difference between soft constraints and regular constraints is that Saturn V can choose to ignore soft constraints... but there's a cost penalty. The cost of this constraint is `1` per queen that isn't placed on a coordinate.

When Saturn V runs this program, it attempts to find a solution that minimizes the cost of the program. Our knowledge of the n-queens problem tells us that for any board of size `n` on a side can fit up to `n` queens on it. However, Saturn V has to figure this out itself. This is the optimization aspect of the program.

Prior to version 0.2, Saturn V runs what's called in the literature a *linear UNSAT-SAT* search to attempt to find the optimum solution. This uses a SAT solver to find the minimum number of soft constraints that can be violated (i.e. the maximum number of queens) while meeting all hard constraints.

This is what Saturn V is thinking:
```
Can all queens fit on the board?
  ...no.
Can all but 1 queen fit on the board?
  ...no.
Can all but 2 queens fit on the board?
  ...no.
Can all but 3 queens fit on the board?
  ...no.
Can all but 4 queens fit on the board?
  ...
  <et cetera>
  ...
Can all but 55 queens fit on the board?
  ...no.
Can all but 56 queens fit on the board?
  ...yes!
```

Saturn V has found the optimal solution: all but 56 positions can fit a queen on an 8x8 chess board. When Saturn V next reads the output of the SAT solver, it will find that the SAT solver has placed 8 queens on the chess board.

However, that's really, really slow! What if we want to see how many queens can fit on a 100x100 chessboard? We have to first ask if all 10,000 queens fit, then if 9,999 queens fit, then if 9,998 queens fit, et cetera, until we converge on the correct answer, which is that 100 queens can fit. More importantly, it's generally very difficult for SAT solvers to prove that a complex constraint problem like this is unsatisfiabile than it is to find a satisfying solution. This means that for every number of queens that is unsatisfiable, the SAT solver has to do a *lot* of work just to move on to one fewer queen.

Instead, Saturn V now uses a *linear SAT-UNSAT* search for the optimum solution.

Saturn V now thinks for an 8x8 chess board:
```
Can no queens fit on the board?
  ...yes.
Can 1 queen fit on the board?
  ...yes.
Can 2 queens fit on the board?
  ...yes.
Can 3 queens fit on the board?
  ...yes.
Can 4 queens fit on the board?
  ...yes.
Can 5 queens fit on the board?
  ...yes.
Can 6 queens fit on the board?
  ...yes.
Can 7 queens fit on the board?
  ...yes.
Can 8 queens fit on the board?
  ...yes.
Can 9 queens fit on the board?
  ...no!
```

Saturn V can conclude that whichever solution the SAT solver has found for 8 queens is the best solution, and that's what it uses as the result. This only takes 10 calls to the SAT solver instead of 57 calls to the SAT solver. For a 100x100 board, it would now make at most 102 calls to the SAT instead of at most 9,901 calls[^solution-improving]. Additionally, the SAT solver is doing a lot less work per invocation. You can think of the SAT solver as placing more queens on the board over time, reusing valid placements when it can. This is much easier than the SAT solver needing to prove for each count of queens why that number of queens doesn't fit.

[^solution-improving]: I say "at most" because Saturn V uses solution-improving search, not just linear-SU search. If the SAT solver finds a solution that is *better* than the current cost query, Saturn V will skip the intermediate cost queries and jump to trying to improve on the new cost.

# OpenBSD

Right, so, OpenBSD. My lovely partner Emma maintains a local OpenBSD-based homelab, so I figured it would be a fun challenge (and useful!) to get my Saturn V server to run on that. Well, now CI automatically compiles binary release builds for OpenBSD! I don't know if they *run* but they certainly compile. That's pretty awesome.
