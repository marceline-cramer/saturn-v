+++
title = "Saturn V v0.2 Release"
description = "What to know about the most recent v0.2 release."
date = 2026-01-25
authors = ["Marceline Cramer"]

[extra]
giscus = true
+++

# Saturn V version 0.2

Yeah, it's only been like a month since I released version v0.1. I
also didn't really say anything about that release, even though it's the
very first official release of Saturn V. Well, that's because it isn't
really a big deal! That's kind of the point. [Release early, release
often](https://en.wikipedia.org/wiki/Release_early,_release_often).

No, I *don't* have testers or users yet, but whatever. I'm still ironing out the
release pipeline, since (fun fact) this is the very first time I've ran a hobby
project that had "real" binary releases and I wasn't just eternally trapped in
pre-alpha. Well, that changes *now*... even if it means that I have to spend
consecutive late nights figuring out how the hell to get GitHub Actions to
compile Saturn V release builds on OpenBSD (more on that later).

# Rudimentary Python bindings

# Pure WebAssembly VSCode extension

# Negation as failure

# Orbital sim

Behold! The most overengineered loading icon of all time.

{{ orbit_demo() }}

It all started when I was in my calculus II class during the summer of 2025.
A classmate brought up the three-body problem in passing, so of course I look
it up on [Wikipedia](https://en.wikipedia.org/wiki/Three-body_problem) for
reference. Scrolling through it, I noticed this really fantastic visualization
of a variety of specific periodic solutions:

<p><a href="https://commons.wikimedia.org/wiki/File:5_4_800_36_downscaled.gif#/media/File:5_4_800_36_downscaled.gif"><img src="https://upload.wikimedia.org/wikipedia/commons/5/5a/5_4_800_36_downscaled.gif" alt="5 4 800 36 downscaled.gif" height="800" width="1000"></a><br>By <a href="//commons.wikimedia.org/w/index.php?title=User:Perossello&amp;action=edit&amp;redlink=1" class="new" title="User:Perossello (page does not exist)">Perosello</a> - <a rel="nofollow" class="external text" href="https://x.com/PeRossello/status/1670803430544142338?s=20">Uploaded by Author</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=133294338">Link</a></p>

My first thought was, "Hey, wouldn't that make for an awesome loading icon?"

I then decided to display three-body solutions throughout the various interfaces
I make for Saturn V as an indicator for when Saturn V is processing the latest
data and forming its decisions.

The three-body problem is a challenge within Newtonian physics of predicting
where three bodies (like planets, moons, stars, wherever) are going to move,
assuming that they exert a gravitational pull on each other and follow Newton's
laws of motion. A *periodic solution* to the three-body problem is finding ways
to arrange three bodies such that they orbit themselves in a stable loop.  With
two bodies, finding stable orbits is relatively straight-forward ([thank you,
Kepler](https://en.wikipedia.org/wiki/Kepler_orbit)). However, because of chaos
theory, three bodies are much harder to mathematically find periodic solutions
to. They are also exceedingly rare in nature because of the very special
circumstances required to keep three bodies in a stable orbit around each other.

Despite the complex physics topics involved in the study of the three-body
problem, it's quite easy to intuitively grasp that periodic solutions to the
three-body solution are remarkable just by looking at them.They simply *look*
unnatural, but they completely follow the usual physical laws we take for
granted. Their beauty exists on the fringe between order and chaos.

To me, this is a really effective metaphor for Saturn V. Saturn V works
under completely logical and natural mechanisms, but because it is crafted
purposefully, it's able to create these complex, special structures that are
otherwise impossible for humans to regulate manually. I can think of other
examples of this sort of "controlled chaos" that would also express Saturn
V's relationship with the natural world, but the three-body problem is unique
because of its visual intuition and shared space theme.

## How the orbital sim works

This is a sidetrack into how I implemented the orbital sim, so feel free to skip
this section, especially if you're not very interested in the mathematics of
orbital mechanics.

The bottom line of it is that I begin with the positions, velocities, and masses
of three bodies from a known solution to the three-body problem. I simulate
those bodies using traditional Newtonian mechanics for as long as the solution
specifies the period lasts. I also take advantage of the time-reversibility
of Newtonian mechanics to simulate the bodies in reverse for the same period,
and linearly interpolate the two simulations end-to-end to correct for any
drifting between the positions of the bodies at the endpoints of the
sim caused by the lack of floating-point precision.[^premature-opt]

[^premature-opt]: This was a premature optimization. Double precision is really
  damn precise.

Once all the position data for the entirety of the simulation is calculated,
the real trick is to then take the discrete Fourier transform of the positions
of the bodies. Because all periodic three-body solutions are highly elliptical,
a handful of the frequency components per-body contain the vast majority of the
information about the orbit. I discard all frequency components above a certain
amplitude, retaining only that small number of dominant components. This is
what's saved to disk. This concludes the "baking" phase of the orbital sim,
which is ran as part of Saturn V's build process.

At runtime, I can load the baked frequency domains for each body for each orbit.
Then, using a couple standard trigonometric functions, I can reconstruct the
position of each body at arbitrary timesteps with a very high degree of accuracy
to the original simulation data. I use this to rapidly compute the points to
render the path trail on, as well as to determine the position of each body
during subframes for the motion blur. By default, the renderer draws 10 motion
blur subframes and 20 path segments for each of the 3 bodies, so that requires
in 10 * 20 * 3 = 600 orbit lookups per frame. I haven't profiled it, but the
renderer runs in WebAssembly and renders the result to a browser canvas with
zero lag or stutter, even on mobile browsers. "Great success," as a certain
fictional Kazakh journalist would say.

# MaxSAT solver goes vroom vroom

You may have heard me babble about SAT (aka [the Boolean satisfiability
problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)).
SAT solvers are how Saturn V makes its decisions. Well,
[MaxSAT](https://en.wikipedia.org/wiki/Maximum_satisfiability_problem)
(particularly *partial weighted MaxSAT*) is how Saturn V determines that some
decisions are better than others.

For example, let's take this Saturn V program:

```rp1
; Each possible coordinate on the board.
define output Coord Integer.
Coord 1.
Coord a :- Coord b, b < 8, a = b + 1.

; Each possible placement of a queen.
define output decision Queen(Coord, Coord).
Queen(row, col) :- Coord row, Coord col.

; At most one queen goes on each row.
constrain(row) <= 1 :- Queen(row, col).

; At most one queen goes on each column.
constrain(col) <= 1 :- Queen(row, col).

; At most one queen can go along each main diagonal.
constrain(diag) <= 1 :- Queen(row, col), diag = row + col.

; At most one queen can go along each orthogonal diagonal.
constrain(diag) <= 1 :- Queen(row, col), diag = row - col.

; Try to place as many queens as possible.
constrain soft(1) (coord) = 1 :- Queen coord.
```

This is identical to the
[n-queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) example except
that instead of specifying that *exactly* one queen goes on each row and column,
*at most* one queen goes on each row and column. This allows for there to be no
queens placed on the board, so we also add that last soft constraint:

```rp1
; Try to place as many queens as possible.
constrain soft(1) (coord) = 1 :- Queen coord.
```

Whereas n-queens is a basic constraint solving problem, this expression of it is
an optimization problem instead. We're trying to place, using a soft constraint,
one queen on each coordinate. The difference between soft constraints and
regular constraints is that Saturn V can choose to ignore soft constraints...
but there's a cost penalty. The cost of this constraint is `1` per queen that
isn't placed on a coordinate.

When Saturn V runs this program, it attempts to find a solution that minimizes
the cost of the program. Our knowledge of the n-queens problem tells us that for
any board of size `n` on a side can fit up to `n` queens on it. However, Saturn
V has to figure this out itself. This is the optimization aspect of the program.

Prior to version 0.2, Saturn V runs what's called in the literature a *linear
UNSAT-SAT* search to attempt to find the optimum solution. This uses a SAT
solver to find the minimum number of soft constraints that can be violated (i.e.
the maximum number of queens) while meeting all hard constraints.

This is what Saturn V is thinking:
```
Can all queens fit on the board?
  ...no.
Can all but 1 queen fit on the board?
  ...no.
Can all but 2 queens fit on the board?
  ...no.
Can all but 3 queens fit on the board?
  ...no.
Can all but 4 queens fit on the board?
  ...
  <et cetera>
  ...
Can all but 55 queens fit on the board?
  ...no.
Can all but 56 queens fit on the board?
  ...yes!
```

Saturn V has found the optimal solution: all but 56 positions can fit a queen
on an 8x8 chess board. When Saturn V next reads the output of the SAT solver, it
will find that the SAT solver has placed 8 queens on the chess board.

However, that's really, really slow! What if we want to see how many queens can
fit on a 100x100 chessboard? We have to first ask if all 10,000 queens fit, then
if 9,999 queens fit, then if 9,998 queens fit, et cetera, until we converge on
the correct answer, which is that 100 queens can fit. More importantly, it's
generally very difficult for SAT solvers to prove that a complex constraint
problem like this is unsatisfiabile than it is to find a satisfying solution.
This means that for every number of queens that is unsatisfiable, the SAT solver
has to do a *lot* of work just to move on to one fewer queen.

Instead, Saturn V now uses a *linear SAT-UNSAT* search for the optimum solution.

Saturn V now thinks for an 8x8 chess board:
```
Can no queens fit on the board?
  ...yes.
Can 1 queen fit on the board?
  ...yes.
Can 2 queens fit on the board?
  ...yes.
Can 3 queens fit on the board?
  ...yes.
Can 4 queens fit on the board?
  ...yes.
Can 5 queens fit on the board?
  ...yes.
Can 6 queens fit on the board?
  ...yes.
Can 7 queens fit on the board?
  ...yes.
Can 8 queens fit on the board?
  ...yes.
Can 9 queens fit on the board?
  ...no!
```

Saturn V can conclude that whichever solution the SAT solver has found for 8
queens is the best solution, and that's what it uses as the result. This only
takes 10 calls to the SAT solver instead of 57 calls to the SAT solver. For a
100x100 board, it would now make at most 102 calls to the SAT instead of at most
9,901 calls[^solution-improving]. Additionally, the SAT solver is doing a lot
less work per invocation. You can think of the SAT solver as placing more queens
on the board over time, reusing valid placements when it can. This is much
easier than the SAT solver needing to prove for each count of queens why that
number of queens doesn't fit.

[^solution-improving]: I say "at most" because Saturn V uses solution-improving
  search, not just linear-SU search. If the SAT solver finds a solution that is
  *better* than the current cost query, Saturn V will skip the intermediate cost
  queries and jump to trying to improve on the new cost.

# OpenBSD

Right, so, OpenBSD. My lovely partner Emma maintains a local OpenBSD-based
homelab, so I figured it would be a fun (and useful!) challenge to get my Saturn
V server to run on that. Well, now CI automatically compiles binary release
builds for OpenBSD! I don't know if they *run* but they certainly compile.
That's pretty awesome.

# Where to next?

Someday soon, I'd like to set up an OpenBSD-based computer at home to run my
personal Saturn V instance 24/7.
