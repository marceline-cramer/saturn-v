; Copyright (C) 2025 Marceline Cramer
; SPDX-License-Identifier: AGPL-3.0-or-later
;
; Saturn V is free software: you can redistribute it and/or modify it under
; the terms of the GNU Affero General Public License as published by the Free
; Software Foundation, either version 3 of the License, or (at your option) any
; later version.
;
; Saturn V is distributed in the hope that it will be useful, but WITHOUT ANY
; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
; FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
; more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with Saturn V. If not, see <https://www.gnu.org/licenses/>.

(sort VarSet (Set i64))

(datatype ValueKind
	(Boolean bool)
	(Integer i64)
	(Real f64))

(datatype Query
	(QueryValue ValueKind Query)
	(QueryVariable i64 Query)
	(QueryNil))

(function query-vars (Query) VarSet :merge (set-union old new))
(set (query-vars (QueryNil)) (set-empty))

(rule
	((= q (QueryValue _ rest)) (= vars (query-vars rest)))
	((set (query-vars q) vars))
	:name "query-vars for QueryValue")

(rule
	((= q (QueryVariable var rest)) (= vars (query-vars rest)))
	((set (query-vars q) (set-insert vars var)))
	:name "query-vars for QueryVariable")

(datatype UnaryOpKind
	(Negate)
	(Not))

(datatype BinaryOpKind
	(Add)
	(Mul)
	(Div)
	(Concat)
	(And)
	(Or)
	(Eq)
	(Lt)
	(Le))

(datatype Expr
	(Variable i64)
	(Value ValueKind)
	(Load i64 Query :cost 1000000)
	(UnaryOp UnaryOpKind Expr :cost 1)
	(BinaryOp BinaryOpKind Expr Expr :cost 1))

; Set-of-expressions sorts used to represent n-ary Boolean ops
; This prevents rewrite permutation explosion on commutativity/associativity
(sort ExprSet (Set Expr))
(function and_children (Expr) ExprSet :merge new)
(function or_children  (Expr) ExprSet :merge new)

(function expr-vars (Expr) VarSet :merge (set-union old new))
(rule ((= e (Variable var))) ((set (expr-vars e) (set-of var))) :name "expr-vars for Variable")
(rule ((= e (Value _))) ((set (expr-vars e) (set-empty))) :name "expr-vars for Value")
(rule ((= e (Load _ q)) (= vars (query-vars q))) ((set (expr-vars e) vars)) :name "expr-vars for Load")
(rule ((= e (UnaryOp _ inner)) (= vars (expr-vars inner))) ((set (expr-vars e) vars)) :name "expr-vars for UnaryOp")

(rule
	((= e (BinaryOp _ lhs rhs)) (= lhs_vars (expr-vars lhs)) (= rhs_vars (expr-vars rhs)))
	((set (expr-vars e) (set-union lhs_vars rhs_vars)))
	:name "expr-vars for BinaryOp")

; Shorthand
(let True (Value (Boolean true)))
(let False (Value (Boolean false)))

; Implementation of arithmetic
(rewrite (BinaryOp (Add) (Value (Integer a)) (Value (Integer b))) (Value (Integer (+ a b))))
(rewrite (BinaryOp (Mul) (Value (Integer a)) (Value (Integer b))) (Value (Integer (* a b))))
(rewrite (BinaryOp (Div) (Value (Integer a)) (Value (Integer b))) (Value (Integer (/ a b))))

; Arithmetic identities
(let zero (Value (Integer 0)))
(let one (Value (Integer 1)))
(rewrite (BinaryOp (Add) a zero) a)
(rewrite (BinaryOp (Mul) a one) a)
(rewrite (BinaryOp (Mul) a zero) zero)

; And logic (set-aware)
(rule
	((= e (BinaryOp (And) a b))
	 (= s (and_children (BinaryOp (And) a b)))
	 (= 0 (set-length (set-diff (set-of (Value (Boolean false))) s))))
	((union e False))
	:name "and-contains-false -> False")

; Or logic (set-aware)
(rule
	((= e (BinaryOp (Or) a b)
	 (= s (or_children (BinaryOp (Or) a b)))
	 (= 0 (set-length (set-diff (set-of (Value (Boolean true))) s)))))
	((union e True))
	:name "or-contains-true -> True")

; Eq logic
(rewrite (BinaryOp (Eq) a a) True)

; Inequality logic
(birewrite (BinaryOp (Lt) a b) (UnaryOp (Not) (BinaryOp (Lt) b a)))
(birewrite (BinaryOp (Le) a b) (UnaryOp (Not) (BinaryOp (Le) b a)))
(birewrite
	(BinaryOp (Or) (BinaryOp (Eq) a b) (BinaryOp (Lt) a b))
	(BinaryOp (Le) a b))

; Not logic
(rewrite (UnaryOp (Not) (UnaryOp (Not) a)) a)
(rewrite (UnaryOp (Not) True) False)
(rewrite (UnaryOp (Not) False) True)

; Negate logic
(rewrite (UnaryOp (Negate) (UnaryOp (Negate) a)) a)
(rewrite (UnaryOp (Negate) (Value (Integer x))) (Value (Integer (- 0 x))))
(rewrite (UnaryOp (Negate) (Value (Real x)))    (Value (Real (- 0.0 x))))

; Associativity
; Currently unused to avoid combinatorial rewrite explosion
(relation associative (BinaryOpKind))

(rule
	((= e (BinaryOp op a (BinaryOp op b c)))
	 (associative op))
	((union e (BinaryOp op (BinaryOp op a b) c)))
	:name "operator associativity")

; Commutativity
(relation commutative (BinaryOpKind))
(set (commutative (Eq)) ())

(rule
	((= e (BinaryOp op a b))
	 (commutative op))
	((union e (BinaryOp op b a)))
	:name "operator commutativity")

; Distributive rules
(birewrite (BinaryOp (Mul) a (BinaryOp (Add) b c)) (BinaryOp (Add) (BinaryOp (Mul) a b) (BinaryOp (Mul) a c)))

(rule
	((= e (BinaryOp (And) a (BinaryOp (Or) b c)))
	 (= orset (or_children (BinaryOp (Or) b c))))
	((union e (BinaryOp (Or) (BinaryOp (And) a b) (BinaryOp (And) a c))))
	:name "and-distribute-right-or")

(rule
	((= e (BinaryOp (And) (BinaryOp (Or) b c) a))
	 (= orset (or_children (BinaryOp (Or) b c))))
	((union e (BinaryOp (Or) (BinaryOp (And) b a) (BinaryOp (And) c a))))
	:name "and-distribute-left-or")

; De Morgan's laws
(birewrite
	(UnaryOp (Not) (BinaryOp (And) a b))
	(BinaryOp (Or) (UnaryOp (Not) a) (UnaryOp (Not) b)))

(birewrite
	(UnaryOp (Not) (BinaryOp (Or) a b))
	(BinaryOp (And) (UnaryOp (Not) a) (UnaryOp (Not) b)))

; Negation of addition negates terms
(birewrite
	(UnaryOp (Negate) (BinaryOp (Add) a b))
	(BinaryOp (Add) (UnaryOp (Negate) a) (UnaryOp (Negate) b)))

; Negation of multiplication cancels out
(birewrite
	(BinaryOp (Mul) (UnaryOp (Negate) a) (UnaryOp (Negate) b))
	(BinaryOp (Mul) a b))

; Instruction data type
(datatype Instr
	(Noop)
	(Sink VarSet Instr :cost 10000000)
	(Filter Expr Instr)
	(FromQuery i64 Query)
	(Let i64 Expr Instr)
	(Merge Instr Instr)
	(Join Instr Instr)
	(Antijoin i64 Query Instr))

; Properties of joins
(rewrite (Join a b) (Join b a))
(rewrite (Join a (Noop)) a)
(rewrite (Join (Filter e lhs) rhs) (Filter e (Join lhs rhs)))

; Two filters in series are equivalent to Boolean AND (set-aware)
(rule
	((= i (Filter (BinaryOp (And) a b) rest)) (= s (and_children (BinaryOp (And) a b))) (= s (set-of a b)))
	((union i (Filter a (Filter b rest))))
	:name "filter-and-2->series")

(rule
	((= i (Filter (BinaryOp (And) a (BinaryOp (And) b c)) rest)) (= s (and_children (BinaryOp (And) a (BinaryOp (And) b c)))) (= s (set-of a b c)))
	((union i (Filter a (Filter b (Filter c rest)))))
	:name "filter-and-3->series")

; A Boolean OR is equivalent to concatenation (set-aware)
(rule
	((= i (Filter (BinaryOp (Or) a b) rest)) (= s (or_children (BinaryOp (Or) a b))) (= s (set-of a b)))
	((union i (Merge (Filter a rest) (Filter b rest))))
	:name "filter-or-2->merge")

(rule
	((= i (Filter (BinaryOp (Or) a (BinaryOp (Or) b c)) rest)) (= s (or_children (BinaryOp (Or) a (BinaryOp (Or) b c)))) (= s (set-of a b c)))
	((union i (Merge (Merge (Filter a rest) (Filter b rest)) (Filter c rest))))
	:name "filter-or-3->merge")

; Fold binary And/Or into sets
(rule
	((= e (BinaryOp (And) a b)))
	((set (and_children e) (set-of a b)))
	:name "binary-and -> and_children")

(rule
	((= e (BinaryOp (Or) a b)))
	((set (or_children e) (set-of a b)))
	:name "binary-or -> or_children")

; When nested binary And/Or are present, also populate the children set
(rule
	((= e (BinaryOp (And) a (BinaryOp (And) b c))))
	((set (and_children e) (set-of a b c)))
	:name "nested and -> and_children")

(rule
	((= e (BinaryOp (Or) a (BinaryOp (Or) b c))))
	((set (or_children e) (set-of a b c)))
	:name "nested or -> or_children")

; Asserted relations on no-ops can be loaded regardless of available variables
(rewrite (Filter (Load r q) rest) (Join rest (FromQuery r q)))

; Calculate the set of variables that are available in each instruction subtree
(function instr-vars (Instr) VarSet :merge (set-union old new))
(rule ((= i (FromQuery _ q)) (= vars (query-vars q))) ((set (instr-vars i) vars)) :name "instr-vars for FromQuery")
(rule ((= i (Let var _ rest)) (= vars (instr-vars rest))) ((set (instr-vars i) (set-insert vars var))) :name "instr-vars for Let")

(rule
	((= i (Filter test rest))
	 (= needed (expr-vars test))
	 (= available (instr-vars rest))
	 (= 0 (set-length (set-diff needed available))))
	((set (instr-vars i) available))
	:name "instr-vars for Filter")

(rule
	((= i (Join lhs rhs))
	 (= lhs_vars (instr-vars lhs))
	 (= rhs_vars (instr-vars rhs)))
	((set (instr-vars i) (set-union lhs_vars rhs_vars)))
	:name "instr-vars for Join")

(rule
	((= i (Merge lhs rhs))
	 (= lhs_vars (instr-vars lhs))
	 (= rhs_vars (instr-vars rhs)))
	((set (instr-vars i) (set-intersect lhs_vars rhs_vars)))
	:name "instr-vars for Merge")

; Empty sinks are no-ops
(rewrite (Sink (set-empty) rest) rest)

; Providing variables removes it from the sink
(rule
	((= i (Sink needed rest))
	 (= provided (instr-vars rest))
	 (= remaining (set-diff needed provided)))
	((union i (Sink remaining rest)))
	:name "provide variables to sink")

; Negated loads can be converted into antijoin instructions
(rule
	((= i (Filter (UnaryOp (Not) (Load r q)) rest))
	 (= needed (query-vars q))
     (= available (instr-vars rest))
	 (= 0 (set-length (set-diff needed available))))
	((union i (Antijoin r q rest)))
	:name "antijoin instruction")

; An assertion of equality can assign and provide if all variables are available
(rule
	((= i (Filter (BinaryOp (Eq) (Variable var) rhs) rest))
	 (= needed (expr-vars rhs))
	 (= available (instr-vars rest))
	 (= 0 (set-length (set-diff needed available)))
	 (set-not-contains available var))
	((union i (Let var rhs rest)))
	:name "equality to let instruction")
